## Thread(스레드)란 ?

- 하나의 프로세스안에서의 여러 실행 흐름이다.
- 하나의 프로세스에 여러 스레드 생성이 가능하다.
- 스레드는 동시 실행이 가능.
- 프로세스 안에 있는 여러 스레드는 해당 `프로세스의 데이터(CODE,HEAP,DATA영역)를 공유`한다.
- `레지스터 상태(PC,SP)와 스택은 독립적으로 생성,관리`된다.

![image](https://user-images.githubusercontent.com/49670068/119253975-afbde380-bbee-11eb-92fd-cb18062b83c8.png)

## Multi Thread(멀티 스레드)

- 프로그램 병렬처리를 위해 멀티 스레드를 사용한다.(멀티스레드로 작업을 나누어 병렬처리가능)
- 현대 CPU는 멀티코어를 갖는다. 즉, 멀티스레드를 이용하면 멀티 코어를 활용도를 높힐 수 있다.

## 스레드의 장점

1. 사용자에 대한 응답성 향상

- 예를 들어 웹서버의 경우 클라이언트가 웹페이지를 요청할때마다 스레드를 생성하여, 작업을 처리할 수 있다.
- 이때, 하나의 스레드로 모든 요청을 처리하는 것보다 요청마다 스레드를 생성하여 처리하는 것이 응답속도가 빠르다.

2. 자원 공유 효율

- 멀티 프로세스를 사용할 경우 IPC 기법을 사용해 데이터를 공유해야한다.
- 허나 멀티 스레드의 경우, 프로세스의 자원을 공유하기 때문에 IPC기법을 쓰지 않아도 된다.

3. 작업이 분리되어, 코드가 간결해진다.

- 작성하기 나름이나, 보통 함수단위로 스레드를 구분하는 경우가 많아, 스레드별로 코드 관리가 편해진다.

## 스레드의 단점

1. 멀티 프로세스에서는 하나의 프로세스가 문제가 생기면, 다른 프로세스에 영향을 주지않지만, 멀티스레드는 하나의 스레드가 문제가 생기면, 다른 스레드에 영향을 줄 수 있다.

![image](https://user-images.githubusercontent.com/49670068/119254140-b00aae80-bbef-11eb-9cb2-c3038f84d9ba.png)

2. 스레드를 많이 생성하면, 컨텍스트 스위칭(오버헤드)이 많이 일어나 성능이 저하 될 수 있다.

- 여러 스레드 생성시 모든 스레드를 스케쥴링 해야하기 때문에 컨텍스트 스위칭이 빈번할 수 밖에없다.

> PThread 란 ?
> POSIX 스레드를 지칭한다. 즉, 리눅스 Thread 관련 표준 API이다.

## 스레드의 동기화 이슈

- 동기화란 작업들 사이에 적절한 실행 시기를 맞추는 것을 말한다.
- 여러 스레드가 동일한 자원에 접근할때, 컨텍스트 스위칭으로 인한 동기화 문제가 발생할 수 있다.

![image](https://user-images.githubusercontent.com/49670068/119254305-8d2cca00-bbf0-11eb-98f3-4f90a043936d.png)

- 위 그림에서 `상단 그림은 Thread1 => Thread2 => Thread1 순서`로 `아래 그림은 Thread1 => Thread2 => Thread1 => Thread2 순서`로 `컨텍스트 스위칭`이 일어 난다고 가정해보자.
- `상단의 그림`은 적절하게 컨텍스트 스위칭이 되어 `동기화 문제가 발생하지 않는 경우`이고, `아래 그림이 문제가 발생하는 경우`이다.
- `g_count는 스레드가 공유하는 데이터`라고 가정.
- 상단 그림은 스레드1이 g_count값을 레지스터로 읽어온후 그 값에 1을 더하여 g_count를 갱신한 직후 스레드2가 동일한 작업, 그리고 다시 스레드1이 동일한 작업을 하여 결과적으로 g_count가 3이된 경우이다. 스레드의 각 작업이 3번 했고, `g_count에 3이라는 결과가 정삭적으로 저장`되어있다.
- 허나 `아래 그림은` 스레드1이 g_count값을 레지스터로 읽어온후 바로 스레드2로 전환되면서, 스레드2도 g_count값을 레지스터로 가져온다. 이때, 아직 스레드1이 값을 갱신하지 않았으므로 0을 가져온다.
- 그리고 다시 스레드1로 전환되면서 g_count를 1로 갱신하고, 다시 스레드2로 전환되면서 g_count를 동일하게 1로 갱신한다.
- 작업은 `2번 실행되어 결과가 2가 되어야하나, 적절치못한 시기에 컨텍스트스위칭이 되면서 문제가 발생`한 것이다.

## 동기화 이슈 해결

- 쓰레드는 프로세스의 모든 데이터에 접근 가능하다.
    - 어느 한 스레드가 공유변수를 갱신하는 동안 다른 스레드가 동시접근하지 못하도록 막아야한다.
    - 즉, 공유 변수에 대해 Exclusive Access(배타적인 접근) 필요.

```python
# 파이썬 예제
lock.acquire() # 다른 스레드가 임계영역에 접근하지 못하도록 Lock
for i in range(100000): # 임계
    g_count += 1        # 영역
lock.release() # 임계 영역 접근 가능하도록 Lock 해제
```

## Mutex(뮤텍스)와 Semaphore(세마포어)의 차이

- 임계 영역에 대한 접근을 막기위해서는 Locking 메커니즘이 필요하다.
    - 뮤텍스 : 임계 영역에 하나의 스레드만 접근가능
    - 세마포어 : 임계 영역에 여러 스레드가 들어갈 수 있음.(Counter 활용)

> 모니터
> - 뮤텍스와 동일하게 임계영역에 하나의 스레드만 접근 가능하다.
> - 뮤텍스는 프로세스간 동기화에 사용하고, 모니터는 하나의 프로세스안에서 스레드간 동기화에 사용된다.
> - 뮤텍스는 os 커널,라이브러리,프레임워크에 의해서 제공하나, 모니터는 라이브러리,프레임워크 자체에서 제공한다.
> - 뮤텍스가 아무래도 좀더 무겁다.

## 세마포어 구현

- P: 검사 (임계영역에 들어갈 때 함수)
    - S 값이 1 이상이면, 임계 영역에 진입후 S값 차람(S가 0이면 대기)
- V: 증가 (임계영역에서 나올 때 함수)
    - S값을 1 더하고, 임계 영역을 나옴
- S: 세마포어 값(초기값만큼의 스레드가 동시에 임계영역 접근 가능)

```
//수도 코드
P(S): wait(S) {
    while S <= 0 //세마포어 값이 0보다 작다면 바쁜대기
    ;
    S--; //대기상태를 탈출하면 1차감
}
V(S): signal(S) {
    S++; //세마포어 값을 늘려 임계영역에 스레드 접근가능 수를 늘린다.
}
```

- 위와 같이 바쁜 대기를 이용하는 방법은 Loop로 인한 cpu에 부하를 걸리게하기때문에 대기큐를 활용하는 방법도 있다.

```
//대기큐 방식의 경우
wait(S) { //임계영역에서 들어갈때
    S -> count--; // count 값 차감
    if(S-> count <= 0) {
        //count 값이 0이하라면 대기 큐에 넣는다.
        block()
    }
}
signal(S) { //임계영역에서 나올떄
    S -> count++; // count 값 증가
    if(S-> count > 0){
        //count 값이 0보다 크다면 
        //대기큐에 가장 앞에 있는 스레드를 꺼내 깨운다.
        wakeup(P);
    }
}
```

## 교착상태(Deadlock)

- 두 개 이상의 스레드가 서로 점유한 자원을 요청할때, 서로 상대방이 끝나기만을 무한정 기다리는 상태가 교착상태이다.

![image](https://user-images.githubusercontent.com/49670068/119256612-7db37e00-bbfc-11eb-8b11-22db9d0bbc32.png)

> 교착상태 발생조건
> 1. 상호배제 : 자신이 점유한 자원을 `다른 스레드가 접근하지 못하도록하는 특징`
> 2. 점유대기 : 자신이 `특정 자원을 점유한 상태에서 다른 자원을 기다리는 상태`
> 3. 비선점 : 스레드가 다른 스레드가 `점유한 자원을 선점할수 없을` 특징
> 4. 순환대기 : 자신이 특정 자원을 점유한 상태에서 `추가적으로 다른 자원을 요청하는 상태`

> 교착상태 해결방법으로는 예방,회피,발견,회복이 있다.
> 예방 : 발생조건 중 하나를 제거하는 방법이다.
> 회피 : 발생조건 중 4번만 제거
> 발견 : 발생 이유를 분석하여, 교착상태의 프로세스와 자원을 발견하는 방법
> 회복 : 교착 상태에 있는 프로세스를 종료시켜 다른 프로세스가 자원을 선점하도록하는 방법

## 기아상태(Starvation)

- 특정 프로세스 또는 스레드의 우선순위가 낮아 원하는 자원을 계속 할당받지 못하는 상태
- 여러 프로세스가 부족한 자원을 요청할때, 우선순위에 의해 계속 뒤로 밀려 특정프로세스가 영원히 자원을 할당받지 못하게 되는 경우가 있다.

> 기아상태 해결방법
> 프로세스의 우선순위를 수시로 변경시키는 방법, 오래 기다린 프로세스의 우선순위를 높혀주는 방법, 우선순위를 제거하여 요청 순서대로 처리하는 방법이 있다.

