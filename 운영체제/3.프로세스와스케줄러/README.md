## 프로세스란 ?

- 실행중인 프로그램(메모리에 적재되어 운영체제의 제어를 받는 프로그램)
- 프로세스 = task = job
- 응용 프로그램과 프로세스는 다르다.
    - 응용 프로그램은 여러개의 프로세스로 이루어 질 수 있다.
- 하나의 응용프로그램은 여러 프로세스(프로그램)가 상호작용 하면서 실행 될 수 있다.

## 스케쥴러

- 프로세스 실행을 관리한다.
- 스케쥴링 알고리즘 : 어떠한 순서로 프로세스를 실행할지 결정
    - 스케쥴링 알고리즘의 목표 : 프로세스 응답시간 최소화(시분할 시스템)를 한거나, CPU 활용도를 높힌다거나(멀티프로그래밍)

## 스케쥴러의 종류

1. FIFO 스케쥴러

- 프로세스를 요청 순서대로 프로세서에 할당한다.(배치 처리 시스템과 동일하다.)
- FCFS(Fisrt Come First Served)라고도 불린다.

![image](https://user-images.githubusercontent.com/49670068/118975463-00df9480-b9af-11eb-8c5d-8b038ab85cfe.png)


2. SJF(Shortest Job First) 스케쥴러

- 실행시간이 가장 짧은 프로세스를 먼저 실행한다.

![image](https://user-images.githubusercontent.com/49670068/118975570-19e84580-b9af-11eb-99f2-39fd093bc991.png)


> ※ RTOS(RealTime OS)와 GPOS(General Purpose OS)
> RTOS: 프로그램의 시작과 종료시간을 완전히 보장하는 OS이다. 언제 프로그램을 정확히 끝내야하는 민감한 작업이 필요한 곳에 사용된다.(원자력 발전소 등등)
> GPOS: 프로세스 실행시간에 민감하지 않고, 일반적인 목적으로 사용되는 OS(윈도우,리눅스등 이있다.)

3. 우선순위 기반 스케쥴러

- 프로세스 우선순위가 높은 것을 우선적으로 프로세스에 할당하는 스케쥴러이다.
- 정적 우선순위 스케쥴러(프로세스마다 우선순위에 고정적), 동적 우선순위 스케쥴러(스케쥴러 상황에따라 우선순위가 동적으로 변경)가 있다.

![image](https://user-images.githubusercontent.com/49670068/118975934-6c296680-b9af-11eb-9184-0ce7ba10dcf0.png)


4. Round Robin 스케쥴러

- 시분할 시스템에 기반되는 스케쥴러이다.
- 실행되는 프로세스가 일정시간 사용하면 스케쥴러가 선점(점유)하여 중지시키고 다른 프로세스가 실행되도록 한다.

![image](https://user-images.githubusercontent.com/49670068/118976312-d9d59280-b9af-11eb-9da0-cefa587d3f85.png)


## 멀티프로그래밍과 Wait

- 멀티프로그래밍 CPU활용도를 극대화 하는 스케쥴링 알고리즘
- Wait : 저장매체로 부터 파일 읽기를 기다리는 시간으로 가정

![image](https://user-images.githubusercontent.com/49670068/118976712-45b7fb00-b9b0-11eb-872f-894863dec579.png)

> 위 그림에서 한 네모당 1초라고 가정 한다면 각 프로그램들의 실제 프로세서 사용시간은 2초이다. 그리고 각 프로세스가 Wait 상태일때, Wait상태가 아닌 프로세스를 프로세서에 할당하여 cpu 활용도를 높힐 수 있다.

## 프로세스 상태

![image](https://user-images.githubusercontent.com/49670068/118976989-a21b1a80-b9b0-11eb-8499-9851a4ef013a.png)

- Run 상태 : 현재 CPU에서 실행중인 상태
- Ready 상태 : CPU를 통해 바로 실행가능한 상태
- Wait(Block) 상태 : 특정 이벤트 발생을 기다리는 상태(예를 들어 파일을 저장매체에서 다 읽게되면 저장매체는 OS로 이벤트를 날리는 데, 이 이벤트를 기다리는 상태이다. 이벤트를 받으면 스케쥴러에 의해 Ready상태가 된다.)

## 프로세스 상태간의 관계

![image](https://user-images.githubusercontent.com/49670068/118977630-561ca580-b9b1-11eb-9d42-cebfb3cbef8a.png)

- RUN => WAIT (IO or Event Wait) : 예를 들어 프로그램에서 open함수로 인해 파일읽기(시스템 콜 : 이것도 인터럽트임)가 수행되는 경우 인터럽트(파일읽기가 완료됐다는 이벤트)가 발생할때까지 대기하는 Wait상태가 된다.
- READY => RUN : 스케쥴러에 의해 프로세스가 프로세서에 할당되어 실행된다.
- RUN => READY : 스케쥴러에 의해 실행중인 프로세스가 선점되어 READY상태로 전환된다
- WAIT => READY : 인터럽트(파일읽기가 완료됐다는 이벤트)가 발생하면 스케쥴러에 의해 READY상태로 전환된다.

## 선점형 스케쥴러와 비선점형 스케쥴러의 차이

- 선점형 스케쥴러 : 스케쥴러가 실행중인 프로세스를 선점하여 중지후 다른 프로세스를 실행시킬 수 있음.
- 비선점형 스케쥴러 : 스케쥴러가 실행중인 프로세스를 선점할 수 없으며, 실행 중 Wait상태가 되지않는 프로세스의 경우 끝날때까지 다른 프로세스를 실행시킬수 없다. (프로세스가 종료되거나 Wait가 되는 경우에만 다른 프로세스를 실행시킬수 있다.)

> `FIFO, SJF, 우선순위 스케쥴러`의 경우 `어떤 프로세스를 먼저 실행`시킬 지에 대한 스케쥴러이며, `Round Robin`은 `시분할 시스템을 위한 선점 스케쥴러`이다.

## 여러 스케쥴링 알고리즘이 조합되어 동작할 수 있습니다.

- 예를 들어 우선순위 스케쥴링과 라운드 로빈 스케쥴링이 조합된 경우

![image](https://user-images.githubusercontent.com/49670068/118979933-f1af1580-b9b3-11eb-9c95-6f89e6fb1150.png)

## 인터럽트란 ?

- 입출력 하드웨어 장치 이벤트 또는 예외상황 발생시 CPU에 알려 처리하는 기술이다.

## 인터럽트가 필요한 이유

1. 프로세스 실행 중, 시분할 시스템에 의해 스케쥴러가 실행 중인 프로세스를 다른 프로세스로 교체시켜야할때 (컴퓨터에 내장된 타이머 칩이 일정시간마다 인터럽트를 보냄)

2. 예를들어 파일 읽기완료시 IO 장치에서 인터럽트를 보내, 스케쥴러가 해당 파일읽기를 요청한 프로세스를 BLOCK에서 READY상태로 바꾸도록 해야함.

3. 예외상황(예를 들어 0으로 나누는 불가능한 연산) 발생시, 인터럽트를 일으켜 프로세스를 종료시켜야함.

> 인터럽트는 프로그램 내부 또는 하드웨어에서 발생시키는 이벤트이다.

## 인터럽트 종류

- 내부 인터럽트(소프트웨어 인터럽트)
    - 프로그램 내부에서 잘못된 명령, 데이터 사용시 발생
        - 0으로 나눌때
        - 사용자 모드에서 허용되지 않는 명령, 주소 접근시
        - 계산결과가 오버플로우,언더플로우 날때

- 외부 인터럽트(하드웨어 인터럽트)
    - 주로 하드웨어에서 발생되는 이벤트 (프로그램 외부)
        - 전원이상
        - 기계문제
        - 키보드입력과 같은 IO 관련이벤트
        - 타이머 이벤트

## 시스템 콜 인터럽트

- 시스템 콜도 소프트웨어 인터럽트이다.
- 시스템 콜 실행시 어셈블리어를 보게되면, 인터럽트 OP코드가 사용된다.

```assembly
//시스템 콜을 실행시키는 어셈블리어 샘플이다.
mov eax, 1 //eax에는 시스템 콜 번호(어떤 시스템콜인지)를 넣는다.
mov ebx, 0 //ebx에는 인자를 넣는다.
int 0x80 //0x80은 인터럽트 중 시스템 콜을 의미
```

## 인터럽트와 시스템 콜

1. 시스템 콜 실행시(int 0x80) CPU를 커널 모드로 바꿔준다.
2. IDT(인터럽트 디스크립터 테이블 : 인터럽트 번호에 해당하는 실행코드 주소가 저장됨)에서 0x80에 해당하는 주소를 찾아서 실행한다.
3. eax로 부터 어떤 시스템콜을 할 것인지, ebx로 부터 인자가 무엇인지를 통해 해당 시스템 콜을 실행한다.
4. 시스템 콜 함수가 실행 완료되면 사용자모드로 변경되어 다음 줄 명령이 실행된다.

## 인터럽트와 사용자모드,커널모드

![image](https://user-images.githubusercontent.com/49670068/118983078-05a84680-b9b7-11eb-80c7-01dab6c3f2eb.png)

- 프로세스 동작시 실제로 인터럽트로 인해 유저모드와 커널모드를 넘나들며 실행된다.


## 인터럽트와 프로세스

![image](https://user-images.githubusercontent.com/49670068/118983279-39836c00-b9b7-11eb-98ae-7f359e3dab81.png)

- 프로세스 실행 중 인터럽트가 발생하면,
- 프로세스를 중단하고, 커널모드에서 인터럽트 처리 함수를 실행한다.
- 인터럽트 처리함수가 완료되면, 프로세스 A 실행을 재개한다.

## 인터럽트와 선점 스케쥴러

- 타이머 칩은 수시로 타이머 인터럽트를 발생시킨다.
- 운영체제가 타이머 인터럽트 발생횟수를 기억해 특정 횟수만큼 발생하면, 현재실행중인 프로세스를 중지하고, 다른 프로세스로 교체한다.(선점 스케쥴링)

```
...
while(true){
    if(count++==5){
        Scheduler();
        count = 0;
    }
}
..
```

## 프로세스 구조

![image](https://user-images.githubusercontent.com/49670068/119229956-28706180-bb55-11eb-8636-7aaecf3b10a9.png)


- 메모리상에 프로세스의 구조는 다음과 같다.
- CODE(TEXT) 영역 : 프로그램 실행 코드 명령어가 있는 영역(실제로는 기계어)
- DATA 영역 : 초기화된 전역변수, static 변수가 있는 영역
- BSS 영역 : 초기화되지 않은 전역변수, static 변수가 있는 영역
- HEAP 영역 : 프로그램 실행 중 `동적으로 생성된 데이터`가 위치하는 영역(malloc or new로 생성된 데이터)
- STACK 영역 : 함수 호출시 마다 스택프레임이 생성되고, 매개변수,지역변수가 저장된다. (스택프레임은 EBP로 구분지어짐) - 다른 영역과는 반대로 공간을 차지해 나간다.

> CPU 레지스터 (PC와 SP는 반드시 알아놓자.)
> PC : 다음 실행할 명령어의 주소
> SP : 현재 스택영역의 최상단을 가르킴(데이터를 넣어야할 위치)
> EBP : 각 함수 호출시마다 생성되는 기준 주소를 저장(해당 값을 바탕으로 버그,에러발생시 발생한 함수 추적)
> EAX : 산술 연산의 결과를 저장하는 레지스터

## 스택 오버플로우란 ??

- 프로세스 메모리 구조 중 스택을 이용한 해킹 기법의 일종이다.

```C
void copy(char *bar){
    char data[6];
    strcpy(data,bar);
}
int main(int argc,char **argv){
    copy(argv[1]);
}
```

- 위와 같은 코드가 있다고 할때, 프로그램 실행시 argv값(실행 매개변수)을 aaaaaaa0xcccc(0xcccc는 악성코드 시작주소라고 가정)로 넣게되면, `스택에서 함수 종료시 RETURN되는 주소를 악성코드 시작주소로 변조`시킬수 있다. 그럼 프로그램 종료시, `PC값이 악성코드 시작주소로 변경`되면서, `악의적인 코드 실행을 유도`할 수 있다.

![image](https://user-images.githubusercontent.com/49670068/119230495-69697580-bb57-11eb-9706-78d805f5a3d5.png)

## PCB (프로세스 제어 블록)

- 메모리 커널영역에 위치한 프로세스의 상태를 저장하는 자료구조이다.
- 아래와 같은 프로세스와 관련된 중요한 정보를 저장한다.
- PROCESS ID
- REGISTER 값(PC,SP등등)
- 스케쥴링 정보(프로세스 상태 : 준비,실행,대기)
- 메모리 사이즈

## PCB와 컨텍스트 스위칭

- CONTEXT SWITCHING (문맥교환)
    - CPU에 실행할 프로세스를 교체하는 기술이다. (시분할 시스템에서 문맥교환을 통해 실행프로세스를 계속 교체한다.)
    - 현재 실행중인 프로세스의 상태를 PCB에 저장하고, 실행할 프로세스의 PCB를 바탕으로 CPU 레지스터를 갱신하여 실행하는 메커니즘이다.

![image](https://user-images.githubusercontent.com/49670068/119230812-c7e32380-bb58-11eb-9162-0e1b46c50f6b.png)

> ※ 컴파일러란 ?
> - 고급언어로 작성된 코드를 기계어로 변환하는 프로그램
> - CPU 아키텍처에 따라 컴파일러를 개발하면, 기존코드 변경없이 CPU에 따라 컴파일러 프로그램을 통해 동일한 로직을 실행시킬 수 있다.
> - 컴파일러로 생성된 바이너리는 어셈블리어로 작성한 바이너리에 비해 속도가 떨어질 수 있다.
> - 문맥 교환 로직은 일종의 오버헤드(목표 작업과는 연관성이 없는 추가적인 시간,자원 소모)이고, 매우 빈번하게 발생한다. 그렇기에 오버헤드로 인한 성능저하를 최소화하기 위해 문맥교환 프로그램(?) OR 로직은 어셈블리어로 많이 작성된다.

## 프로세스간 커뮤니케이션

- 프로세스는 기본적으로 다른 프로세스의 공간을 접근할 수 없다.(보안 목적상)

## 프로세스 통신이 필요한 이유 ?

- 작업을 빨리 처리하기 위해 프로그램을 멀티 프로세스로 동시 실행하는 경우(EX: 1~10000까지 더하는 작업을 4개의 프로세스가 나누어 작업), 각 프로세스가 작업을 완료하고 하나의 프로세스가 결과를 취합할 필요성이 있음. 이때, 각 프로세스간 통신이 필요함.
- 웹서버의 경우, 클라이언트로부터 요청이 오면 HTML 파일을 제공하는데, 요청시마다 fork()함수로 새로운 자식 프로세스를 생성하여, 즉각대응한다. 이때, 프로세스간 통신을 통해 상태를 공유하여, 웹서버가 여러 상황에 따라 적절하게 동작하도록 할수 있다.

## IPC 기법

- file이라는 매개체를 사용하여 프로세스간 데이터를 전달할 수 있다.
- 허나 file을 사용하여 실시간으로 원하는 프로세스에 직접 데이터를 전달하는 것은 어렵다.
- 그래서 여러 IPC(프로세스 통신) 기법이 등장하였다.
- 대부분 IPC 기법들은 커널 영역을 사용한다.

> 프로세스 메모리 영역에서 커널영역은 실제로 모든 프로세스가 공유하는 영역(동일한 공간을 가르키고 있다.)이다.

1. PIPE (파이프)

- 파이프는 프로세스간 데이터를 전달하기 위해 단방향 통신을 제공한다.
- fork()함수로 자식 프로세스 생성시, 부모와 자식간 pipe를 통해 단방향 통신이 가능하다.

![image](https://user-images.githubusercontent.com/49670068/119231350-71c3af80-bb5b-11eb-8030-33257d2216ef.png)

```C
char* msg = "hello child process !";
int main(){
    char buf[255];
    int fd[2], pid, nbytes;
    if(pipe(fd) < 0){
        // pipe(fd)로 파이프를 생성하면 fd[0],fd[1]에 
        // 파이프에 데이터 입출력시 필요한 번호가 들어감
        // 리턴값이 음수라면 파이프생성 실패
        exit(1);
    }
    pid = fork(); //자식 프로세스 생성
    if(pid > 0){ //부모프로세스는 pid가 0이아님
        write(fd[1],msg,MSGSIZE);//write함수를 통해 파이프에 데이터 입력
        exit(0);
    }else{
        nbytes = read(fd[0],buf,MSGSIZE);
        //read함수를 통해 파이프로 부터 데이터를 buf로 전달받음.
        printf("%d %s\n",nbytes,buf);
        exit(0);
    }
    return 0;
}
```

2. 메시지 큐

- 큐 자료구조로 구성된 메시지 큐라는 것을 사용하여 프로세스간 데이터 전달
- KEY를 사용하여 부모자식이 아니어도, 데이터 전달이 가능하다.

```C
//a 프로세스
msqid = msgget(key,msgflag); //key는 1234, key로 메시지큐를 생성하면 id를 반환한다.
msgsnd(msqid,&sbuf,buf_length,IPC_NOWAIT); //id를 사용해 메시지를 전달한다.
//b프로세스
msqid = msgget(key,msgflag); //key는 동일하게 1234
msgrcv(msqid,&rbuf,MSGSZ,1,0); //A프로세스에서 전달한 데이터를 rbuf로 받는다.
```

3. 공유메모리

- 커널에 프로세스가 접근가능한 공유 메모리 영역을 생성하여, 데이터를 읽고 덮어쓸 수 있다.

```C
//공유메모리 생성 및 공유메모리 주소 얻기
shmid = shmget((key_t)1234,SIZE,IPC_CREAT|0666);//key를 사용하여 생성
shmaddr = shmat(shmid,(void *)0,0); //주소를 얻는다.
//공유 메모리에 데이터를 덮어 쓴다.
strcpy((char *)shmaddr,"LINUX PROGRAMMING");
//공유메모리에서 읽기
printf("%s \n", (char *)shmaddr);
```

4. 시그널

- 유닉스에서 30년이상 사용된 방법이다.
- 커널 또는 프로세스에서 다른 프로세스에 어떤 이벤트가 발생되었는지 알리는 기법이다.
- 프로세스에 특정 시그널 발생시 실행될 핸들러를 설정할 수 있다.(시그널을 무시한거나, 특정 함수를 실행시킨다거나) 허나, 지정하지 않으면 커널에서 기본적으로 지정한 동작이 수행된다.
- PCB에 해당 프로세스가 처리해야하는 시그널 관련 정보를 저장한다.
- 시그널이 발생하면 커널모드로 전환되며, 사용자 모드로 전환될때 시그널에 대한 커널함수를 실행한다.(단 해당 함수가 커널 기본 동작이 아닌 사용자가 정의한 동작이라면 즉, 사용자 모드로 수행가능한 함수라면 사용자 모드로 전환하여 수행한다.)

> 주요 시그널
> - SIGKILL : 프로세스를 죽여라
> - SIGALARM : 알람을 발생시킨다.
> - SIGSTP : 프로세스 중지 (Ctrl + z 키보드 입력시 발생)
> - SIGCONT : 중지 프로세스를 실행해라.

```C
static void signal_handler(int signo){
    printf("Catch SIGINT!\n");
    exit(EXIT_SUCCESS);
}

int main(void){
    if(signal(SIGINT, signal_handler) == SIG_ERR){
        //SIGINT 발생시 signal_handler함수를 실행한다.
        printf("Can't catch SIGINT!\n");
        exit(EXIT_FAILURE);
    }
    for(;;)
        pause();

    return 0;
}
```

5. 소켓

- 소켓은 네트워크 통신을 위한 기술이다.
- 원격에 위한 서버와 클라이언트 두 단말간에 네트워크 기반 통신을 위한 기술로 사용한다.
- 하나의 컴퓨터 안에서 두개의 프로세스간 통신 기법으로도 사용가능하다.

![image](https://user-images.githubusercontent.com/49670068/119231992-6756e500-bb5e-11eb-9dc8-a5f6da695cd0.png)


